package com.sksamuel.tabby.validation

fun interface Parser<in I, out A, out E> {

   companion object {

      /**
       * Returns an identity [Parser] for a type I which is the entry point
       * to building parsers.
       *
       * Eg,
       *
       * Parser<T>()...parse(t)
       */
      operator fun <I> invoke(): Parser<I, I, Nothing> = parser { it.valid() }
   }

   fun parse(input: I): Validated<E, A>

   /**
    * Creates a new [Parser] from J -> A by transforming an input J into a value I and then
    * feeding that I into the given parser of I -> A.
    */
   @ExperimentalTabby
   fun <J> contramap(f: (J) -> I): Parser<J, A, E> {
      val self = this
      return parser { self.parse(f(it)) }
   }
}

/**
 * Returns a [Parser] backed by the given function.
 */
fun <I, A, E> parser(fn: (I) -> Validated<E, A>) = Parser<I, A, E> { input -> fn(input) }

/**
 * Lifts an existing [Parser] to support lists of the input types supported by
 * the underlying parser.
 *
 * In other words, given an parser, this will return a parser that handles lists of the inputs.
 *
 * @return a parser that accepts lists
 */
fun <I, A, E> Parser<I, A, E>.repeated(): Parser<List<I>, List<A>, E> {
   return parser { input ->
      input.map { this@repeated.parse(it) }.traverse()
   }
}

/**
 * Lifts an existing [Parser] to support lists of the input types supported by
 * the underlying parser. This version of repeated supports upper and lower bounds
 * on the list size.
 *
 * In other words, given an parser, this will return a parser that handles lists of the inputs.
 *
 * @param min the minimum number of elements in the list
 * @param max the maximum number of elements in the list
 *
 * @return a parser that accepts lists
 */
fun <I, A, E> Parser<I, A, E>.repeated(
   min: Int = 0,
   max: Int = Int.MAX_VALUE,
   ifInvalidSize: (Int) -> E
): Parser<List<I>, List<A>, E> {
   return parser { input ->
      if ((min..max).contains(input.size)) input.map { this@repeated.parse(it) }.traverse()
      else ifInvalidSize(input.size).invalid()
   }
}

/**
 * Wraps an existing String -> String [Parser] to reject blank strings,
 * with the error message generated by the given function [ifBlank].
 *
 * @param ifBlank the error generating function
 *
 * @return invalid if the input string contains only whitespace, otherwise valid
 */
fun <I, E> Parser<I, String, E>.notBlank(ifBlank: () -> E): Parser<I, String, E> {
   return flatMap {
      if (it.isBlank()) ifBlank().invalid() else it.valid()
   }
}

/**
 * Wraps an existing [Parser] to accept nulls as input, which are returned as
 * errors, with the error message generated by the given function [ifNull].
 *
 * @param ifNull the error generating function
 *
 * @return valid if the input string is not null, otherwise invalid
 */
fun <I, A, E> Parser<I, A, E>.notNull(ifNull: () -> E): Parser<I?, A, E> {
   return parser { input: I? ->
      if (input == null) ifNull().invalid() else this@notNull.parse(input)
   }
}

/**
 * Wraps an existing String -> String [Parser] to accept nulls as input, which are
 * returned as errors. Also rejects blank strings. Error messages are generated by
 * the given function [ifError].
 *
 * @param ifError the error generating function
 *
 * @return valid if the input string is not null and not blank, otherwise invalid
 */
fun <E> Parser<String, String, E>.notNullOrBlank(ifError: () -> E): Parser<String?, String, E> {
   return parser { input: String? ->
      if (input.isNullOrBlank()) ifError().invalid() else this@notNullOrBlank.parse(input)
   }
}

/**
 * Widens an existing [Parser] to accept null inputs which are returned as valid.
 */
fun <I, A, E> Parser<I, A, E>.nullable(): Parser<I?, A?, E> {
   return Parser { input ->
      if (input == null) Validated.Valid(null) else this@nullable.parse(input)
   }
}

/**
 * Narrows an existing String -> String [Parser] by enforcing a min length on the input string.
 *
 * For strings which have length shorter than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is greater than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.minlen(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when {
         it.length < len -> ifError(it).invalid()
         else -> it.valid()
      }
   }

/**
 * Narrows an existing String -> String [Parser] by enforcing a max length on the input string.
 *
 * For strings which have length longer than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is less than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.maxlen(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when {
         it.length > len -> ifError(it).invalid()
         else -> it.valid()
      }
   }

/**
 * Narrows an existing String -> String [Parser] by enforcing an exact length on the input string.
 *
 * For strings which have length that differs than the given [len] arguments, an invalid is
 * returned with the error message generated by [ifError].
 *
 * @param len the max length, inclusive
 * @param ifError the error generating function
 *
 * @return valid if the input string is less than or equal to [len] or an invalid otherwise.
 */
fun <I, E> Parser<I, String, E>.length(len: Int, ifError: (String) -> E): Parser<I, String, E> =
   flatMap {
      when (it.length) {
         len -> it.valid()
         else -> ifError(it).invalid()
      }
   }

/**
 * Wraps ane existing [Parser] that permits nullable output, with a parser that
 * replaces null output with the result of the given function [ifNull].
 *
 * @param ifNull the default generating function
 *
 * @return the same underlying value if not null, or the default otherwise
 */
fun <I, A, E> Parser<I, A?, E>.default(ifNull: () -> A): Parser<I, A, E> {
   return parser { input ->
      this@default.parse(input).flatMap {
         it?.valid() ?: ifNull().valid()
      }
   }
}

/**
 * Chains a [Parser] to convert String? -> Int.
 * An input of type
 */
fun <I, E> Parser<I, String, E>.int(ifError: (String) -> E): Parser<I, Int, E> =
   flatMap {
      val i = it.toIntOrNull()
      i?.valid() ?: ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.positive(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it > 0) it.valid() else ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.nonneg(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it >= 0) it.valid() else ifError(it).invalid()
   }

fun <I, E> Parser<I, Int, E>.negative(ifError: (Int) -> E): Parser<I, Int, E> =
   flatMap {
      if (it < 0) it.valid() else ifError(it).invalid()
   }

/**
 * Extends a [Parser] of output type string to parse that string into a double.
 * If the string cannot be parsed into a double, then the error is generated by the
 * given function [ifError].
 *
 * Note: This parser accepts nullable inputs if the receiver accepts nullable inputs
 * and a null is considered a failing case.
 */
fun <I, E> Parser<I, String, E>.double(ifError: (String) -> E): Parser<I, Double, E> =
   flatMap {
      val d = it.toDoubleOrNull()
      d?.valid() ?: ifError(it).invalid()
   }

/**
 * Extends a [Parser] of output type string to parse that string into a double.
 * If the string cannot be parsed into a double, then the error is generated by the
 * given function [ifError].
 *
 * Note: This parser accepts nullable inputs if the receiver accepts nullable inputs
 * and a null is considered a failing case.
 */
fun <I, E> Parser<I, String, E>.float(ifError: (String) -> E): Parser<I, Float, E> =
   flatMap {
      val f = it.toFloatOrNull()
      f?.valid() ?: ifError(it).invalid()
   }

/**
 * Extends a [Parser] of output type string to parse that string into a double.
 * If the string cannot be parsed into a double, then the error is generated by the
 * given function [ifError].
 *
 * Note: This parser accepts nullable inputs if the receiver accepts nullable inputs
 * and a null is considered a failing case.
 */
fun <I, E> Parser<I, String, E>.long(ifError: (String) -> E): Parser<I, Long, E> =
   flatMap {
      val l = it.toLongOrNull()
      l?.valid() ?: ifError(it).invalid()
   }

fun <I, E> Parser<I, String, E>.boolean(ifError: (String) -> E): Parser<I, Boolean, E> =
   flatMap {
      val b = it.toBooleanStrictOrNull()
      b?.valid() ?: ifError(it).invalid()
   }


/**
 * Modifies a String -> String [Parser] by trimming the output string to remove prefix
 * and suffix whitespace.
 *
 * @return the output of the underlying parser with whitespace trimmed.
 */
fun <I, E> Parser<I, String, E>.trim(): Parser<I, String, E> = map { it.trim() }

/**
 * Modifies a String -> String [Parser] by uppercasing the output string.
 *
 * @return the output of the underlying parser with the output uppercased.
 */
fun <I, E> Parser<I, String, E>.uppercase(): Parser<I, String, E> = map { it.uppercase() }

/**
 * Modifies a String -> String [Parser] by lowercasing the output string.
 *
 * @return the output of the underlying parser with the output lowercased.
 */
fun <I, E> Parser<I, String, E>.lowercase(): Parser<I, String, E> = map { it.lowercase() }

/**
 * Returns a [Parser] that maps the result of this parser by invoking the given function [f]
 * when the underlying parser returns a valid instance.
 *
 * @param f the function invoked to map the output of the underlying parser.
 *
 * @return a parser which returns the modified result of this parser.
 */
fun <I, A, B, E> Parser<I, A, E>.map(f: (A) -> B): Parser<I, B, E> = parser { this@map.parse(it).map(f) }

/**
 * Returns a [Parser] that maps the result of this parser by invoking the given function [f]
 * and flattening the output of that function.
 *
 * @param f the function invoked to map the output of the underlying parser.
 *
 * @return a parser which returns the modified and flattened result of this parser.
 */
fun <I, A, B, E> Parser<I, A, E>.flatMap(f: (A) -> Validated<E, B>): Parser<I, B, E> =
   parser { this@flatMap.parse(it).flatMap(f) }

/**
 * Returns a [Parser] that maps the non-null results of a nullable parser.
 *
 * If the output of the underlying parser is null, then it is passed through unchained.
 * Otherwise, the result A is transformed by the function [f] to B.
 *
 * @param f the function invoked to map the non-null output of the underlying parser.
 *
 * @return a parser which returns the modified result of this parser.
 */
fun <I, A, B, E> Parser<I, A?, E>.mapIfNotNull(f: (A) -> B): Parser<I, B?, E> = parser { input ->
   this@mapIfNotNull.parse(input).map { if (it == null) null else f(it) }
}

/**
 * Returns a [Parser] that rejects the output of this parser if the output fails to pass
 * the given predicate [p].
 *
 * In other words, if the underlying parser returns a valid output, that output is then
 * passed to the given function, and if that function returns false, it is rejected.
 * The error message is provided by the given [ifFalse] function.
 *
 * @param p the predicate to test input
 * @param ifFalse the error generating function
 *
 * @return a parser which rejects input based on the result of predicate [p]
 */
fun <I, A, E> Parser<I, A, E>.filter(p: (A) -> Boolean, ifFalse: (A) -> E): Parser<I, A, E> {
   return flatMap { if (p(it)) it.valid() else ifFalse(it).invalid() }
}

/**
 * Returns a [Parser] that rejects the output of this parser if the output is not one
 * of the given acceptable values. In the case of rejection, the error message
 * is generated by the given function [ifFalse].
 *
 * @param values the allow list of values
 * @param ifFalse the error generating function
 *
 * @return a parser which rejects input if not in an allow list.
 */
fun <I, A, E> Parser<I, A, E>.oneOf(values: List<A>, ifFalse: (A) -> E): Parser<I, A, E> {
   return flatMap { if (values.contains(it)) it.valid() else ifFalse(it).invalid() }
}

/**
 * Returns a method reference from I to Validated<E,A> as a [Parser].
 */
@ExperimentalTabby
fun <I, A, E> (kotlin.reflect.KFunction1<I, Validated<E, A>>).asParser(): Parser<I, A, E> {
   val self = this@asParser
   return parser { self.invoke(it) }
}

@Retention(value = AnnotationRetention.BINARY)
@RequiresOptIn(level = RequiresOptIn.Level.WARNING)
public annotation class ExperimentalTabby

